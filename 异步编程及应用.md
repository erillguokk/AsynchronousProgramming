#       简介

对于多线程、异步编程的学习理解，最基础的jdk概念，使用过的jdk中的异步编程包，一些源码理解，netty的使用，spring中多线程的应用案例

# jdk中的异步

1. 基本概念

   进程是资源分配的最小单位，线程是程序执行的最小单位，每启动一个进程，系统就会分配地址空间，建立数据表来维护代码段、堆栈段和数据段。线程共享进程中的数据。我是这么理解的，qq和微信就是两个进程，在qq中可以打开多个对话框，每一个对话框就是一个线程。

2. 线程基本实现：

   2.1继承thread

   ```
   public class MyThread extends Thread { 
    public void run() { 
    System.out.println("MyThread.run()"); 
    } 
   } 
   MyThread myThread1 = new MyThread(); 
   myThread1.start();
   ```

   2.2实现runnable接口

   ```
   public class MyThread extends OtherClass implements Runnable { 
    public void run() { 
    System.out.println("MyThread.run()"); 
    } 
   }
   
   MyThread myThread = new MyThread(); 
   Thread thread = new Thread(myThread); 
   thread.start();
   ```

   

3. 线程的状态：

   1. 新建状态:
      使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。

   2. 就绪状态:
      当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。

   3. 运行状态:
      如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。

   4. 阻塞状态:

      如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：

      - 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。
      - 同步阻塞：线程在获取 synchronized同步锁失败(因为同步锁被其他线程占用)。
      - 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。

   5. 死亡状态:
      一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。

      

   ![](C:\Users\guosheng\AppData\Roaming\Typora\typora-user-images\image-20200617102846949.png)

   

4. join方法理解：

   在这个例子中 t2线程必须等待t1线程结束之后才会结束。如果t1线程十分耗时，那么在主线程中调t1.interrupt()；t1就会结束等待,并执行catch里面的内容和后序的代码，然后t2也会结束等待，很优雅。如果调用stop方法就会导致t1直接结束，"t1线程结束"不会输出。这就是中断带来的效果

   ```java
   public static void main(String [] args) throws Exception{
       final Thread t1 = new Thread(new Runnable() {
         @Override
         public void run() {
           System.out.println("t1线程开始");
           try{
             Thread.sleep(10000);
           }catch(Exception e){
             System.out.println(e.getMessage());
           }
           System.out.println("t1线程结束");
         }
       });
       
       t1.start();
   
       Thread t2 = new Thread(new Runnable() {
         @Override
         public void run() {
           System.out.println("t2线程开始");
           try{
             Thread.sleep(5000);
             t1.join();
           }catch(Exception e){
             System.out.println(e.getMessage());
           }
           System.out.println("t2线程结束");
         }
       });
       t2.start();
       
       Thread.sleep(30000);
       if(t1.isAlive()){
         t1.interrupt();
   //      t1.stop();
       }
     }
   
   ```

5. FutureTask:

   ```java
   public class AsyncFutureExample {
   public static String doSomethingA() {
   try {
   Thread.sleep(2000);
   } catch (InterruptedException e) {
   e.printStackTrace();
   }
   System.out.println("--- doSomethingA---");
   return "TaskAResult";
   }
   public static String doSomethingB() {
   try {
   Thread.sleep(2000);
   } catch (InterruptedException e) {
   e.printStackTrace();
   }
   System.out.println("--- doSomethingB---");
   return "TaskBResult";
   }
   public static void main(String[] args) throws InterruptedException, ExecutionException {
   long start = System.currentTimeMillis();
   // 1.创建future任务
   FutureTask<String> futureTask = new FutureTask<String>(() -> {
   String result = null;
   try {
   result = doSomethingA();
   } catch (Exception e) {
   e.printStackTrace();
   }
   return result;
   });
   // 2.开启异步单元执行任务A
   Thread thread = new Thread(futureTask, "threadA");
   thread.start();
   // 3.执行任务B
   String taskBResult = doSomethingB();
   // 4.同步等待线程A运行结束
   String taskAResult = futureTask.get();
   // 5.打印两个任务执行结果
   System.out.println(taskAResult + " " + taskBResult);
   System.out.println(System.currentTimeMillis() - start);
   }
   }
   
   使用线程池：
   public static void main(String[] args) throws InterruptedException, ExecutionException {
   long start = System.currentTimeMillis();
   // 1.开启异步单元执行任务A
   Future<String> futureTask = POOL_EXECUTOR.submit(() -> {
   String result = null;
   try {
   result = doSomethingA();
   } catch (Exception e) {
   e.printStackTrace();
   }
   return result;
   });
   // 2.执行任务B
   String taskBResult = doSomethingB();
   // 3.同步等待线程A运行结束
   String taskAResult = futureTask.get();
   // 4.打印两个任务执行结果
   System.out.println(taskAResult + " " + taskBResult);
   System.out.println(System.currentTimeMillis() - start);
   }
   ```

   当创建一个FutureTask时，其任务状态初始化为NEW，当我们把任务提交到线程或者线程池后，会有一个线程来执行该FutureTask任务，具体是调用其run方法来执行任务。在任务执行过程中，我们可以在其他线程调用FutureTask的get()方法来等待获取结果，如果当前任务还在执行，则调用get的线程会被阻塞然后放入FutureTask内的阻塞链表队列；多个线程可以同时调用get方法，这些线程可能都会被阻塞并放到阻塞链表队列中。当任务执行完毕后会把结果或者异常信息设置到outcome变量，然后会移除和唤醒FutureTask内阻塞链表队列中的线程节点，进而这些由于调用FutureTask的get方法而被阻塞的线程就会被激活
   为了从Future获取结果，我们必须调用get()方法，而该方法还是会在任务执行完毕前阻塞调用线程，这明显不是我们想要的。
   我们真正想要的是：
   ·可以将两个或者多个异步计算结合在一起变成一个，这包含两个或者多个异步计算是相互独立的情况，也包含第二个异步计算依赖第一个异步计算结果的情况。
   ·对反应式编程的支持，也就是当任务计算完成后能进行通知，并且可以以计算结果作为一个行为动作的参数进行下一步计算，而不是仅仅提供调用线程以阻塞的方式获取计算结果。
   ·可以通过编程的方式手动设置（代码的方式）Future的结果；FutureTask不能实现让用户通过函数来设置其计算结果，而是在其任务内部来进行设置。
   ·可以等多个Future对应的计算结果都出来后做一些事情。
   为了克服FutureTask的局限性，以及满足我们对异步编程的需要，JDK8中提供了CompletableFuture

6. CompletableFuture

   默认情况下支撑CompletableFuture异步运行的是ForkJoinPool。ForkJoinPool本身也是一种ExecutorService，与其他ExecutorService（比如ThreadPoolExecutor）相比，不同点是它使用了工作窃取算法来提高性能，其内部每个工作线程都关联自己的内存队列，正常情况下每个线程从自己队列里面获取任务并执行，当本身队列没有任务时，当前线程会去其他线程关联的队列里面获取任务来执行。这在很多任务会产生子任务或者有很多小的任务被提交到线程池来执行的情况下非常高效
   ForkJoinPool中有一个静态的线程池commonPool可用且适用大多数情况。commonPool会被任何未显式提交到指定线程池的ForkJoinTask执行使用。使用commonPool通常会减少资源使用（其线程数量会在不活跃时缓慢回收，并在任务数比较多的时候按需增加）。默认情况下，commonPool的参数可以通过system properties中的三个参数来控制：
   ·java.util.concurrent.ForkJoinPool.common.parallelism：并行度级别，非负整数。
   ·java.util.concurrent.ForkJoinPool.common.threadFactory：ForkJoinWorker ThreadFactory的类名。
   ·java.util.concurrent.ForkJoinPool.common.exceptionHandler：Uncaught ExceptionHandler的类名。
   可以使用ForkJoinPool的构造函数显式设置线程个数，默认情况下线程个数等于当前机器上可用的CPU个数

   6.1实现异步任务A，执行完毕后，激活异步任务B执行，需要注意的是，这种方式激活的异步任务B是拿不到任务A的执行结果的

   ```
   // I thenRun不能访问oneFuture的结果
   public static void thenRun() throws InterruptedException, ExecutionException {
   // 1.创建异步任务，并返回future
   CompletableFuture<String> oneFuture = CompletableFuture.supplyAsync(new Supplier<String>() {
   @Override
   public String get() {
   // 1.1休眠2s，模拟任务计算
   try {
   Thread.sleep(2000);
   } catch (InterruptedException e) {
   e.printStackTrace();
   }
   // 1.2返回计算结果
   return "hello";
   }
   });
   // 2.在future上施加事件，当future计算完成后回调该事件，并返回新future
   CompletableFuture twoFuture = oneFuture.thenRun(new Runnable() {
   @Override
   public void run() {
   // 2.1.1当oneFuture任务计算完成后做一件事情
   try {
   Thread.sleep(1000);
   } catch (Exception e) {
   e.printStackTrace();
   }
   System.out.println(Thread.currentThread().getName());
   System.out.println("--after oneFuture over doSomething--");
   }
   });
   // 3.同步等待twoFuture对应的任务完成，返回结果固定为null
   System.out.println(twoFuture.get());
   }
   thenApplyAsync(Function<? super T,? extends U> fn, Executor executor)来指定设置的回调事件使用自定义线程池线程来执行，也就是oneFuture对应的任务与在其上设置的回调执行将不会在同一个线程中执行
   ```

   6.2基于thenAccept实现异步任务，可以拿到执行结果

   ```
   "public static void thenAccept() throws InterruptedException, ExecutionException {
   // 1.创建异步任务，并返回future
   CompletableFuture<String> oneFuture = CompletableFuture.supplyAsync(new Supplier<String>() {
   @Override
   public String get() {
   // 1.1休眠2s，模拟任务计算
   try {
   Thread.sleep(2000);
   } catch (InterruptedException e) {
   e.printStackTrace();
   }
   // 1.2返回计算结果
   return "hello";
   }
   });
   // 2.在future上施加事件，当future计算完成后回调该事件，并返回新future
   CompletableFuture twoFuture = oneFuture.thenAccept(new Consumer<String>() {
   @Override
   public void accept(String t) {
   // 2.1.1对oneFuture返回的结果进行加工
   try {
   Thread.sleep(1000);
   } catch (Exception e) {
   e.printStackTrace();
   }
   System.out.println("--after oneFuture over doSomething--" + t);
   }
   });
   // 3.同步等待twoFuture对应的任务完成，返回结果固定为null
   System.out.println(twoFuture.get());
   }
   ```

   6.3基于whenComplete设置回调函数，当异步任务执行完毕后进行回调，不会阻塞调用线程

   ```
   public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException {
   // 1.创建一个CompletableFuture对象
   CompletableFuture<String> future = CompletableFuture.supplyAsync(new Supplier<String>() {
   @Override
   public String get() {
   // 1.1模拟异步任务执行
   try {
    Thread.sleep(1000);
   } catch (InterruptedException e) {
   e.printStackTrace();
   }
   // 1.2返回计算结果
   return "hello,jiaduo";
   }
   });
   // 2.添加回调函数
   future.whenComplete(new BiConsumer<String, Throwable>() {
   @Override
   public void accept(String t, Throwable u) {
   // 2.1如果没有异常，打印异步任务结果
   if (null == u) {
   System.out.println(t);
   } else {
   // 2.2打印异常信息
   System.out.println(u.getLocalizedMessage());
   }
   }
   });
   // 3.挂起当前线程，等待异步任务执行完毕
   Thread.currentThread().join();
   }
   "这里代码3挂起了main函数所在线程，是因为具体执行异步任务的是ForkJoin的commonPool线程池，其中线程都是Deamon线程，所以，当唯一的用户线程main线程退出后整个JVM进程就退出了。并且会导致死循环，因为在主线程上挂起主线程，仅为了看到效果而已，不必在意代码具体作用。
   守护线程：指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分，当所有用户线程结束的时候整个jvm就退出
   ```

   6.4与stream结合使用：

   ```java
   实现异步调用不同提供者的机器的一个服务
   // 1.生成ip列表
   List<String> ipList = new ArrayList<String>();
   for (int i = 1; i <= 10; ++i) {
   ipList.add("192.168.0." + i);
   }
   // 2.并发调用
   long start = System.currentTimeMillis();
   List<CompletableFuture<String>> futureList = ipList.stream()
   .map(ip -> CompletableFuture.supplyAsync(() -> rpcCall(ip, ip)))//同步转换为异步
   .collect(Collectors.toList());//收集结果
   //3.等待所有异步任务执行完毕
   List<String> resultList = futureList.stream()
   .map(future -> future.join())
   　　//同步等待结果
   .collect(Collectors.toList());
   　　//对结果进行收集
   // 4.输出
   resultList.stream().forEach(r -> System.out.println(r));
   System.out.println("cost:" + (System.currentTimeMillis() - start));
   
   通过使用CompletableFuture.supplyAsync方法把rpc的同步调用转换为了异步，也就是把同步调用结果转换为了CompletableFuture对象，所以操作符map返回的是一个CompletableFuture，然后collect操作把所有的CompletableFuture对象收集为list后返回。
   ·此外，这里多个rpc调用时是并发执行的，不是顺序执行，因为CompletableFuture.supplyAsync方法把rpc的同步调用转换为了异步
   
   ```

   

7. 线程池的使用：

   7.1基本概念：

   ThreadPoolExecutor(int corePoolSize,//核心线程个数
   int maximumPoolSize,//最大线程个数
   long keepAliveTime,//非核心不活跃线程最大存活时间
   TimeUnit unit,//keepAliveTime的单位
   BlockingQueue<Runnable> workQueue,//阻塞队列类型
   ThreadFactory threadFactory,//线程池创建工厂
   RejectedExecutionHandler handler)//拒绝策略

   ```
   public static String doSomethingA() {
   try {
   Thread.sleep(2000);
   } catch (InterruptedException e) {
   e.printStackTrace();
   }
   System.out.println("--- doSomethingA---");
   return "A Task Done";
   }
   // 0自定义线程池
   private final static int AVALIABLE_PROCESSORS = Runtime.getRuntime().availableProcessors();
   private final static ThreadPoolExecutor POOL_EXECUTOR = new ThreadPoolExecutor(AVALIABLE_PROCESSORS,
   AVALIABLE_PROCESSORS * 2, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<>(5),
   new NamedThreadFactory("ASYNC-POOL"), new ThreadPoolExecutor.CallerRunsPolicy());
   public static void main(String[] args) throws InterruptedException, ExecutionException {
   // 1.开启异步单元执行任务A
   Future<?> resultA = POOL_EXECUTOR.submit(() -> doSomethingA());
   // 2.同步等待执行结果
   System.out.println(resultA.get());
   }
   }
   ```

   ![image-20200617112645485](C:\Users\guosheng\AppData\Roaming\Typora\typora-user-images\image-20200617112645485.png)

   7.2源码分析execute方法：

   ```
   public void execute(Runnable command) {
   //(1) 如果任务为null，则抛出NPE异常
   if (command == null)
   throw new NullPointerException();
   //（2）获取当前线程池的状态+线程个数变量的组合值
   int c = ctl.get();
   //（3）当前线程池线程个数是否小于corePoolSize,小于则开启新线程运行
   if (workerCountOf(c) < corePoolSize) {
   if (addWorker(command, true))
   return;
   c = ctl.get();
   }
   //（4）如果线程池处于RUNNING状态，则添加任务到阻塞队列
   if (isRunning(c) && workQueue.offer(command)) {
   //（4.1）二次检查
   int recheck = ctl.get();
   //（4.2）如果当前线程池状态不是RUNNING则从队列删除任务，并执行拒绝策略
   if (! isRunning(recheck) && remove(command))
   reject(command);
   //（4.3）如果当前线程池线程为空，则添加一个线程
   else if (workerCountOf(recheck) == 0)
   addWorker(null, false);
   }
   //（5）如果队列满了，则新增线程，新增失败则执行拒绝策略
   else if (!addWorker(command, false))
   reject(command);
   }
   ·代码3是指如果当前线程池线程个数小于corePoolSize，则会在调用方法addWorker新增一个核心线程执行该任务。
   ·如果当前线程池线程个数大于等于corePoolSize则执行代码4，如果当前线程池处于RUNNING状态则添加当前任务到任务队列。这里需要判断线程池状态是因为线程池有可能已经处于非RUNNING状态，而非RUNNING状态下是抛弃新任务的。
   ·如果任务添加任务队列成功，则执行代码4.2对线程池状态进行二次校验，这是因为添加任务到任务队列后，执行代码4.2前线程池的状态有可能已经变化了，如果当前线程池状态不是RUNNING则把"任务从任务队列移除，移除后执行拒绝策略；如果二次校验通过，则执行代码4.3重新判断当前线程池里面是否还有线程，如果没有则新增一个线程。
   ·如果代码4添加任务失败，则说明任务队列满了，那么执行代码5尝试调用addWorker方法新开启线程来执行该任务；如果当前线程池的线程个数大于maximumPoolSize则addWorker返回false，执行配置的拒绝策略"。
   至今没有遇到过需要不同的拒绝策略的场景，基本都是默认的策略。
   ```

   

   ![image-20200617112704008](C:\Users\guosheng\AppData\Roaming\Typora\typora-user-images\image-20200617112704008.png)

   7.3实际项目应用：与CountDownLatch联合使用。生成支付宝账单，微信账单、平台账单。生成之后上传到结算平台。三种账单并行生成，主线程等待账单生成结束之后，执行上传操作

   

```java
 String str = JSONObject.fromObject(requestJson).getString("reportDate");
        final Date date;
        try {
            if (StringUtils.isEmpty(str)) {
                return "入库时间为空";
            }
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            date = sdf.parse(str);
            CountDownLatch commanderPrepareLatch = new CountDownLatch(4);
            ExecutorService service = Executors.newCachedThreadPool();
            long start = System.currentTimeMillis();
            logger.info("---生成账单开始-----" + start);
            logger.info("---生成账单开始-----" + start);
            service.submit(new Runnable() {
                @Override
                public void run() {
                    //生成支付宝账单
                    try {
                        PayBillBean aliPayBillBean = new PayBillBean();
                        aliPayBillBean.setDate(DateUtil.getSplitDateTime(date));
                        aliPayBillBean.setPayment(BillConstant.PAYMENT_ALI);
                        aliPayBillBean.setBillType(BillConstant.SIGNCUSTOMER);
                        reconciliationService.getPayDetailBill(aliPayBillBean, BillConstant.ALI_ZIP, DateUtil.getDateTime(date));
                    } catch (Exception e) {
                        e.printStackTrace();
                    } finally {
                        commanderPrepareLatch.countDown();
                    }
                }
            });
            service.submit(new Runnable() {
                @Override
                public void run() {
                    try {
                        PayBillBean aliPayBillBean = new PayBillBean();
                        //生成微信账单
                        aliPayBillBean.setDate(DateUtil.getSplitDateTime(date));
                        aliPayBillBean.setPayment(BillConstant.PAYMENT_WEIXIN);
                        aliPayBillBean.setBillType(BillConstant.SIGNCUSTOMER);
                        reconciliationService.getPayDetailBill(aliPayBillBean, BillConstant.WEIXIN_DOWNLOAD_SIGNCUSTOMER, DateUtil.getDateTime(date));
                    } catch (Exception e) {
                        e.printStackTrace();
                    } finally {
                        commanderPrepareLatch.countDown();
                    }
                }
            });
            service.submit(new Runnable() {
                @Override
                public void run() {
                    try{
                        PayBillBean aliPayBillBean1 = new PayBillBean();
                        aliPayBillBean1.setDate(DateUtil.getSplitDateTime(date));
                        aliPayBillBean1.setPayment(BillConstant.PAYMENT_WEIXIN);
                        aliPayBillBean1.setBillType(BillConstant.TRADE);
                        reconciliationService.getPayDetailBill(aliPayBillBean1, BillConstant.WEIXIN_DOWNLOAD_TRADE, DateUtil.getDateTime(date));
                    }catch (Exception e) {
                        e.printStackTrace();
                    } finally {
                        commanderPrepareLatch.countDown();
                    }

                }
            });
            service.submit(new Runnable() {
                @Override
                public void run() {
                    try {
                        //生成平台账单文件
                        reconciliationService.getOrderDetail(date);

                    } catch (Exception e) {
                        e.printStackTrace();
                    } finally {
                        commanderPrepareLatch.countDown();
                    }
                }
            });
            try {
                commanderPrepareLatch.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                service.shutdown();
                long end = System.currentTimeMillis();
                logger.info("---生成账单结束-----" + (end - start));
            }
            //上传文件到sftp
            reconciliationService.uploadFiles(date);
        } catch (Exception e) {
            return "上传文件,程序出现异常";
        }
            return "成功";
    }
```

# nio:

- ## 基本概念：

三大核心组件selector 、channel、buffer

- ## buffer:

buffer本身是一块内存，底层实现上，实际上是个数组，数据的读和写是通过buffer来实现的

nio可以允许buffer实现读写的切换，buffer.filp();//读写切换的开关

所有数据的读写都是通过buffer来进行的，永远不会出现直接向channel读取或者写入的情况

```java
public static void main(String [] args)throws  Exception{
        FileInputStream fileInputStream = new FileInputStream(new String("C:\\Users\\lenovo\\a.txt"));
        FileChannel fileChannel = fileInputStream.getChannel();
        ByteBuffer byteBuffer = ByteBuffer.allocate(512);
        byte[] message = "hello world ".getBytes();
        fileChannel.read(byteBuffer);
        byteBuffer.flip();
        while (byteBuffer.remaining()>0){
            byte b = byteBuffer.get();
            System.out.println(b);

        }
        fileInputStream.close();
    }

public static void main(String [] args)throws  Exception{
        FileOutputStream fileOutputStream = new FileOutputStream("aa.txt");
        FileChannel fileChannel = fileOutputStream.getChannel();
        ByteBuffer byteBuffer = ByteBuffer.allocate(512);
        byte[] message = "hello world ".getBytes();

       for(int i=0;i<message.length;i++){
           byteBuffer.put(message[i]);
       }
       byteBuffer.flip();
       fileChannel.write(byteBuffer);
       fileOutputStream.close();
    }
```

1. buffer源码分析：

   三个属性：position、limit、capacity

   0<=mark<=position<=limit<=capacity

   capacity是元素的个数

   limit是无法去读或者写的第一个元素的索引（可以读或者写的最大的位置）,永远也不会超过capacity

   position下一个被读或者写的下一个元素的索引(当前正在读或者写的位置)，永远也无法超过limit

   三者的位置，以及调用flip()方法之后的位置（**重点**），见实例

   flip的作用：将limit的值设为当前的position,将position设为0；

   clear的作用：将limit的值设置为capacity,将position设为0，这个操作会覆盖未读的数据；

   （HeapByteBuffer）compact的作用：将所有未读的数据复制到buffer的起始位置，将position设置为最后一个未读元素的后面，将limit设置为capacity。buffer准备好了并且不会覆盖未读的数据

   ```java
   public static void main(String [] args)throws  Exception{
           ByteBuffer byteBuffer = ByteBuffer.allocate(512);
           byte[] message = "hello world ".getBytes();
           byteBuffer.put(message);
           System.out.println("初始状态---"+byteBuffer.position()+":"+byteBuffer.limit());
           byteBuffer.flip();
           System.out.println("初始状态2---"+byteBuffer.position()+":"+byteBuffer.limit());
           while (byteBuffer.remaining()>0){
               byte b = byteBuffer.get();
               //System.out.println(b);
           }
           System.out.println("结束状态---"+byteBuffer.position()+":"+byteBuffer.limit());
           //byteBuffer.reset();
           //byteBuffer.clear();
          // byteBuffer.flip();
           byte[] message2 = "hello worl".getBytes();
           byteBuffer.put(message2);
           System.out.println("结束状态2---"+byteBuffer.position()+":"+byteBuffer.limit());
   
       }
   ```

   

2. DirectBuffer:

   调用native方法即本地方法在堆外内存生成directBuffer,能够提升效率

   如果使用HeapByteBuffer，当与外设进行交互的时候会将jvm中的数据对象拷贝到堆外内存，多了一个拷贝的过程

   为什么要拷贝？

   因为要与外设进行操作，必须是在操作系统层面，虽然操作系统可以访问到堆上的内存但是

   考虑到gc的时候如果正在与外设进行io交互，对于标记清除算法的jvm,进行gc的时候会出现混乱，所以必须有一次拷贝的过程。

   但是DirectBuffer，他是不会在jvm堆中在生成对象了，直接和io进行交互，也就不会有拷贝的过程，所以称之为零拷贝，堆外内存由操作系统进行维护。

   实现：DirectBuffer分成两部分，一部分是java堆，一部分是native,

   java堆上维护了一个address，对应了堆外内存的地址，当address被清除的时候，堆外内存的数据也会清除。

   详见：知乎https://www.zhihu.com/question/57374068/answer/152691891，后文也会对零拷贝进行深入分析

   ```java
   public static void main(String [] args) throws  Exception{
           FileInputStream fileInputStream = new FileInputStream("");
           FileChannel inputChannel = fileInputStream.getChannel();
           FileOutputStream fileOutputStream = new FileOutputStream("");
           FileChannel outputChannel = fileOutputStream.getChannel();
           ByteBuffer byteBuffer = ByteBuffer.allocateDirect(512);//分配堆外内存，和c语言类似的方法
           while(true){
               byteBuffer.clear();
               int read = inputChannel.read(byteBuffer);
               if(-1 == read) break;
               byteBuffer.flip();
               outputChannel.write(byteBuffer);
           }
           fileInputStream.close();
           fileOutputStream.close();
       }
   ```

   

3. mappedByteBuffer：

   内存映射文件:允许java直接从内存访问文件

   ```java
   public static void main(String [] args) throws  Exception{
           /**
            * 内存映射文件，直接在内存中修改文件内容
            */
           RandomAccessFile randomAccessFile = new RandomAccessFile("C:\\data\\report\\upload\\2019-06\\ddd.txt","rw");
           FileChannel  fileChannel = randomAccessFile.getChannel();
           int count = 0;
           MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE,0,fileChannel.size());
           for(int x=0;x<fileChannel.size();x++){
               if(mappedByteBuffer.get(x)==10){
                   count = x;
                   break;
               }
           }
           int length = (int)fileChannel.size();
           byte [] bytes = new byte[length-count];
           mappedByteBuffer.get(bytes,count+1,length-1);
           mappedByteBuffer.flip();
           mappedByteBuffer.put(bytes,0,length-count);
           randomAccessFile.close();
       }
   RandomAccessFile可以设置读取的指针位置和写入的指针位置，如：下面是从网上看到的一个大神的例子，结合cyclicBarrier和RandomAccessFile，对文件进行分页，每一页是一个线程去读取，并对文件的每一行进行处理
   private final static int AVALIABLE_PROCESSORS = Runtime.getRuntime().availableProcessors();//获取当前cpu核数，一般以这个为线程池个数   
   public class BigReader {
       private int threadPoolSize;
       private Charset charset;
       private int bufferSize;
       private IFileHandle handle;
       private ExecutorService executorService;
       private long fileLength;
       private RandomAccessFile rAccessFile;
       private Set<StartEndPair> startEndPairs;
       private CyclicBarrier cyclicBarrier;
       private AtomicLong counter = new AtomicLong(0);
   
       public BigReader(File file, IFileHandle handle, Charset charset, int bufferSize, int threadPoolSize){
           this.fileLength = file.length();
           this.handle = handle;
           this.charset = charset;
           this.bufferSize = bufferSize;
           this.threadPoolSize = threadPoolSize;
           try {
               this.rAccessFile = new RandomAccessFile(file,"r");
           } catch (FileNotFoundException e) {
               e.printStackTrace();
           }
           this.executorService = Executors.newFixedThreadPool(threadPoolSize);
           startEndPairs = new HashSet<StartEndPair>();
       }
   
       public void start(){
           long everySize = this.fileLength/this.threadPoolSize;
           try {
               calculateStartEnd(0, everySize);
           } catch (IOException e) {
               e.printStackTrace();
               return;
           }
   
           final long startTime = System.currentTimeMillis();
           cyclicBarrier = new CyclicBarrier(startEndPairs.size(), () -> {
               System.out.println("use time: "+(System.currentTimeMillis()-startTime));
               System.out.println("all line: "+counter.get());
               shutdown();
           });
           for(StartEndPair pair:startEndPairs){
               System.out.println("分配分片："+pair);
               this.executorService.execute(new SliceReaderTask(pair));
           }
       }
   
       private void calculateStartEnd(long start,long size) throws IOException{
           if(start>fileLength-1){
               return;
           }
           StartEndPair pair = new StartEndPair();
           pair.start=start;
           long endPosition = start+size-1;
           if(endPosition>=fileLength-1){
               pair.end=fileLength-1;
               startEndPairs.add(pair);
               return;
           }
   
           rAccessFile.seek(endPosition);
           byte tmp =(byte) rAccessFile.read();
           while(tmp!='\n' && tmp!='\r'){
               endPosition++;
               if(endPosition>=fileLength-1){
                   endPosition=fileLength-1;
                   break;
               }
               rAccessFile.seek(endPosition);
               tmp =(byte) rAccessFile.read();
           }
           pair.end=endPosition;
           startEndPairs.add(pair);
   
           calculateStartEnd(endPosition+1, size);
   
       }
   
       public void shutdown() {
           try {
               this.rAccessFile.close();
           } catch (IOException e) {
               e.printStackTrace();
           }
           this.executorService.shutdown();
       }
   
       private void handle(byte[] bytes) throws UnsupportedEncodingException {
           String line = null;
           if (this.charset == null) {
               line = new String(bytes);
           } else {
               line = new String(bytes, charset);
           }
           if (line != null && !"".equals(line)) {
               this.handle.handle(line);
               counter.incrementAndGet();
           }
       }
   
   
   
       private static class StartEndPair {
           public long start;
           public long end;
   
           @Override
           public String toString() {
               return "star="+start+";end="+end;
           }
       }
   
       private class SliceReaderTask implements Runnable {
           private long start;
           private long sliceSize;
           private byte[] readBuff;
   
           public SliceReaderTask(StartEndPair pair) {
               this.start = pair.start;
               this.sliceSize = pair.end - pair.start + 1;
               this.readBuff = new byte[bufferSize];
           }
   
   
           @Override
           public void run() {
               try {
                   MappedByteBuffer mapBuffer = rAccessFile.getChannel().map(FileChannel.MapMode.READ_ONLY, start, this.sliceSize);
                   ByteArrayOutputStream bos = new ByteArrayOutputStream();
                   for (int offset = 0; offset < sliceSize; offset += bufferSize) {
                       int readLength;
                       if (offset + bufferSize <= sliceSize) {
                           readLength = bufferSize;
                       } else {
                           readLength = (int) (sliceSize - offset);
                       }
                       mapBuffer.get(readBuff, 0, readLength);
                       for (int i = 0; i < readLength; i++) {
                           byte tmp = readBuff[i];
                           //碰到换行符
                           if (tmp == '\n' || tmp == '\r') {
                               handle(bos.toByteArray());
                               bos.reset();
                           } else {
                               bos.write(tmp);
                           }
                       }
                   }
                   if (bos.size() > 0) {
                       handle(bos.toByteArray());
                   }
                   cyclicBarrier.await();//测试性能用
               } catch (Exception e) {
                   e.printStackTrace();
               }
           }
       }
   
       public static class Builder{
           private int threadSize=1;
           private Charset charset;
           private int bufferSize=1024*1024;
           private IFileHandle handle;
           private File file;
           public Builder(String file,IFileHandle handle){
               this.file = new File(file);
               if(!this.file.exists())
                   throw new IllegalArgumentException("文件不存在！");
               this.handle = handle;
           }
   
           public Builder threadPoolSize(int size){
               this.threadSize = size;
               return this;
           }
   
           public Builder charset(Charset charset){
               this.charset= charset;
               return this;
           }
   
           public Builder bufferSize(int bufferSize){
               this.bufferSize = bufferSize;
               return this;
           }
   
           public BigReader build(){
               return new BigReader(this.file,this.handle,this.charset,this.bufferSize,this.threadSize);
           }
       }
       public static void main(String [] args) throws  Exception{
   //        TestHandle handle = new TestHandle();
   //        BigReader.Builder builder = new Builder("C:\\Users\\lenovo\\Desktop\\报表模板\\稽核文档\\a.csv",handle);
   //        BigReader bigReader = builder.threadPoolSize(2).build();
   //        bigReader.start();
          
       }
   
   }
   
   ```
   
   
   
4. Scattering与Gathering:

   Scattering将来自于一个channel的数据读到多个buffer，按照顺序，第一个buffer满了之后，就读到第二个，实例：实现数据的分门别类，比如网络操作自定义协议，（请求头1，请求头2，请求体)把第一个请求头读取到第一个buffer,第二个读取到第二个buffer，不用读取之后再次解析数据。

   Gathering按照顺序，将多个buffer的内容写到channel中.

   Scattering与Gathering在零拷贝中有着重要的应用。见零拷贝深入分析
   
   ```java
   public static void main(String [] args) throws  Exception{
           ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
           InetSocketAddress address =  new InetSocketAddress(8898);
           serverSocketChannel.socket().bind(address);
           int messageLength = 9;
           ByteBuffer [] buffers = new ByteBuffer[3];
           buffers[0] = ByteBuffer.allocate(2);
           buffers[1] = ByteBuffer.allocate(3);
           buffers[2] = ByteBuffer.allocate(4);
           SocketChannel  socketChannel = serverSocketChannel.accept();
           while(true){
               int byteRead = 0;
               while(byteRead < messageLength){
                 long r = socketChannel.read(buffers);
                 byteRead += r;
                 System.out.println("byteRead:"+byteRead);
                   Arrays.asList(buffers).stream().map(buffer->"position:"+
                           buffer.position()+",limit:"+buffer.limit()).forEach(System.out::println);
               }
               Arrays.asList(buffers).forEach(buffer->{
                   buffer.flip();
               });
               long byteWritten = 0;
               while(byteWritten<messageLength){
                   long r = socketChannel.write(buffers);
                   byteWritten += r;
   
               }
               Arrays.asList(buffers).forEach(byteBuffer -> {
                   byteBuffer.clear();
               });
               System.out.println("read:"+byteRead+","+"write:"+byteWritten);
           }
   
    }
   ```
   
   



- ## channel

  与stream不同，channel是双向的，一个流只可能是InputOutStream或者OutputStream,channel打开后可以进行读取或者写入

  channel可以更好的反映底层操作系统的真实情况。因为在linux中，底层操作系统的通道就是双向的,基本实例见buffer

- ## sellector

  1. 概念：

     普通网络编程：每一个连接都需要服务端启动一个线程来进行处理，比较消耗资源，所以适合并发场景不是很高的场景。

     传统的基于io的网络编程：

     new ServerSocket();

     serverSocker.bind(port);//port用于客户端和服务端进行连接的端口，实际的数据传输的端口由服务端选择未被占用的端口中随机分配

     while(true){

     serverSocket.accept();//阻塞,等待客户端连接

     new Thread(socket).run(){

     socket.getInputStream();//获取流

       }

     } 

     缺点：每个链接都需要一个线程的处理，多个线程之间上下文切换开销很大，当连接上没有数据传递的时候线程始终在运行，造成线程资源的浪费

     event：事件（异步的处理）

     nio编程模型特点：服务端可以使用一个线程来处理多个客户端的连接，最终处理每个连接是同一个线程，通过事件来触发。nio是一个最简单的reactor模式的实现

     selectionKey:将selector注册到可选择的channel上是通过selectionKey对象进行的

     维护了三种selection的集合，标识了一些事件

     key-select 当前注册到selector中的channel的所有事件（已连接、读写、连接关闭）、

     selected-key 感兴趣的事件（比如读写）是key-set的子集

     canceled-key 不在感兴趣的事件 是key-set的子集

  2. 基本实例：

     服务器端监听5个端口号，一个线程处理所有客户端的连接

     ```java
     public static void main(String [] args) throws  Exception{
             int [] ports = new int[5];
             ports[0] = 5000;
             ports[1] = 5001;
             ports[2] = 5002;
             ports[3] = 5003;
             ports[4] = 5004;
             Selector selector = Selector.open();
     
            for(int i =0;i<ports.length;i++){
                ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
                serverSocketChannel.configureBlocking(false);//配置channel是否阻塞
                ServerSocket serverSocket = serverSocketChannel.socket();
                InetSocketAddress address = new InetSocketAddress(ports[i]);
                serverSocket.bind(address);
                serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);//注册selecttor并且标识感兴趣的事件，连接事件
            }
            while (true){
                int numbers = selector.select();//表示选择的数量，即key-set的数量
                //获取到selected-key的集合即获取到事件
                Set<SelectionKey> selectionKeys =  selector.selectedKeys();
                Iterator<SelectionKey> iterator = selectionKeys.iterator();
                int byteRead = 0;
                while(iterator.hasNext()){
                    SelectionKey selectionKey = iterator.next();
                    if(selectionKey.isAcceptable()){//
                        //真正的连接,selector与channel关联
                        ServerSocketChannel  serverSocketChannel = (ServerSocketChannel) selectionKey.channel();
                        SocketChannel  socketChannel =  serverSocketChannel.accept();
                        socketChannel.configureBlocking(false);
                        socketChannel.register(selector,SelectionKey.OP_READ);//将读事件添加到集合，这样才会到else if当中
                        iterator.remove();//一定要删除掉，表示这个事件已经结束，否则会重复监听
                        System.out.println("获取到了客户端的连接"+socketChannel);
                    }else  if(selectionKey.isReadable()){
                        SocketChannel  socketChannel = (SocketChannel) selectionKey.channel();
                        while(true){
                            ByteBuffer  byteBuffer =  ByteBuffer .allocate(512);
                            byteBuffer.clear();
                            int read  = socketChannel.read(byteBuffer);
                            if(read<=0)break;
                            byteBuffer.flip();
                            socketChannel.write(byteBuffer);
                            byteRead += read;
                        }
                        System.out.println("读取：" + byteRead + ","+"来自于：" + socketChannel);
                        iterator.remove();
                    }
                }
            }
     
         }
     ```

     

  3. nio实现聊天程序：

     ```java
     public class NioTestServer8 {
         private static Map<String,SocketChannel> clientMap = new HashMap<>();//维护客户端的连接信息
         public static void main(String [] args) throws Exception{
             ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();//建立连接的作用
             serverSocketChannel.configureBlocking(false);
             ServerSocket serverSocket = serverSocketChannel.socket();
             serverSocket.bind(new InetSocketAddress(8899));
             Selector selector = Selector.open();
             serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);//开始连接的时候只有一个事件，关注连接事件
             while(true){
                 try {
                     selector.select();//监听所有通道的关注的事件，也就是去轮询所有的channel，并返回关注的事件的数量，一旦有事件发生就会继续执行。比如选择器只对某个通道的read和write操作感兴趣，那么选择器在检查该通道时，只会检查通道的read和write操作是否已经处在就绪状态。。
                     Set<SelectionKey> selectionKeySet = selector.selectedKeys();
                     selectionKeySet.forEach(selectionKey -> {
                         final SocketChannel client ;
                         try{
                             if(selectionKey.isAcceptable()){
                                 //连接建立，获取到连接到的channl，注册更多的感兴趣的事件
                                  ServerSocketChannel serverSocketChannel1 = (ServerSocketChannel)selectionKey.channel();
                                  client = serverSocketChannel1.accept();//真实的连接
                                 client.configureBlocking(false);
                                 client.register(selector,SelectionKey.OP_READ);//关注读取事件
                                 String uuid = UUID.randomUUID()+"";
                                 clientMap.put(uuid,client);
                             }else if(selectionKey.isReadable()){
                                 client = (SocketChannel)selectionKey.channel();
                                 ByteBuffer readBuffer = ByteBuffer.allocate(1024);
                                 int count = client.read(readBuffer);
                                 if(count>0){
                                     readBuffer.flip();
                                     Charset charset = Charset.forName("utf-8");
                                     String receiveMessage = String.valueOf(charset.decode(readBuffer).array());
                                     System.out.println(client + ":" + receiveMessage);
                                     String sendKey = "";
                                     for(Map.Entry<String, SocketChannel> entry:clientMap.entrySet()){
                                         if(client == entry.getValue()){
                                             sendKey = entry.getKey();
                                             break;
                                         }
                                     }
                                     for(Map.Entry<String, SocketChannel> entry:clientMap.entrySet()){
                                         SocketChannel value = entry.getValue();
                                         ByteBuffer writeBuffer = ByteBuffer.allocate(1024);
                                         writeBuffer.put((sendKey +":"+receiveMessage).getBytes());
                                         writeBuffer.flip();
                                         value.write(writeBuffer);
                                     }
                                 }
                             }
                         }catch (Exception e){
     
                         }
                     });
                    selectionKeySet.clear();
                    //开始的时候连接通道标识了连接事件，只对连接事件感兴趣
                     //获取到真正的通道的时候标识了读事件，只对读事件感兴趣
                     //每次访问后都remove()相应的SelectionKey，但是移除了selectedKeys中的SelectionKey不代表移除了selector中的channel信息(这点很重要)
                 }catch (Exception e){
     
                 }
             }
     
         }
     }
     
     
     public class NioTestClient8 {
         public static void main(String [] args){
             try{
                 SocketChannel socketChannel = SocketChannel.open();
                 socketChannel.configureBlocking(false);
                 Selector selector = Selector.open();
                 socketChannel.register(selector, SelectionKey.OP_CONNECT);
                 socketChannel.connect(new InetSocketAddress("127.0.0.1",8899));
                 while(true){
                     selector.select();
                     Set<SelectionKey> selectionKeySet = selector.selectedKeys();
                     for(SelectionKey selectionKey : selectionKeySet){
                         SocketChannel client = (SocketChannel)selectionKey.channel();
                         if(selectionKey.isConnectable()){
                             if(client.isConnectionPending()){
                                 //连接是否处在正在进行的状态
                                 client.finishConnect();//完成连接，连接已经建立
                                 ByteBuffer writeBuffer = ByteBuffer.allocate(1024);
                                 writeBuffer.put((LocalDateTime.now()+"连接成功").getBytes());
                                 writeBuffer.flip();
                                 client.write(writeBuffer);
                                 ExecutorService executorService = Executors.newSingleThreadExecutor(Executors.defaultThreadFactory());
                                 executorService.submit(new Runnable() {
                                     @Override
                                     public void run() {
                                         while(true){
                                             try {
                                                 writeBuffer.clear();
                                                 InputStreamReader inputStreamReader = new InputStreamReader(System.in);
                                                 BufferedReader br = new BufferedReader(inputStreamReader);
                                                 String sendMessage = br.readLine();
                                                 writeBuffer.put(sendMessage.getBytes());
                                                 writeBuffer.flip();
                                                 client.write(writeBuffer);
                                             } catch (Exception e) {
                                                 e.printStackTrace();
                                             }
     
                                         }
                                     }
                                 });
     
                             }
                             client.register(selector,SelectionKey.OP_READ);
                         } else if(selectionKey.isReadable()){
                             SocketChannel socketChannel1 = (SocketChannel)selectionKey.channel();
                             ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
                             int count = client.read(byteBuffer);
                             if(count>0){
                                 String receiveMessage = new String(byteBuffer.array(),0,count);
                                 System.out.println(receiveMessage);
                             }
                         }
                         selectionKeySet.clear();
                     }
     
     
                 }
     
             }catch(Exception e) {
                 e.printStackTrace();
             }
         }
     }
     ```

     



# netty

- 基本概念：是一个异步的事件驱动的网络应用框架，用于可维护的、高性能协议的服务端和客户端的快速开发。

  学习netty从一个一个实例开始，代码了解了之后，开始学习reator模式，netty源码分析，零拷贝深入分析、dubbo中的netty应用

  

- 基本实例：

  所有的netty代码基本都是类似于这个实例，是一个死循环，服务端与客户端会不停的发信息

  客户端：

  ```java
  public class MyClient {
      public static void main(String [] args){
          EventLoopGroup eventLoopGroup = new NioEventLoopGroup();
          try {
              Bootstrap bootstrap = new Bootstrap();
              bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class).handler(new MyClientInitializer());
              ChannelFuture channelFuture = bootstrap.connect("localhost",8898).sync();
              channelFuture.channel().closeFuture().sync();
          } catch (Exception e) {
              e.printStackTrace();
          } finally {
              eventLoopGroup.shutdownGracefully();
          }
      }
  }
  
  public class MyClientHandler extends SimpleChannelInboundHandler<String > {
      @Override
      protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception {
          System.out.println(channelHandlerContext.channel().remoteAddress());
          System.out.println("client receive:"+ s);
          //channelHandlerContext.channel().writeAndFlush("client 发送:UUID"); client不需要channel
         channelHandlerContext.writeAndFlush("client 发送的:UUID");
      }
  
      @Override
      public void channelActive(ChannelHandlerContext ctx) throws Exception {
          ctx.writeAndFlush("来自客户端的问候");
      }
  
      @Override
      public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
          cause.printStackTrace();
          ctx.close();
      }
  }
  
  public class MyClientInitializer extends ChannelInitializer<SocketChannel> {
      @Override
      protected void initChannel(SocketChannel socketChannel) throws Exception {
          ChannelPipeline channelPipeline = socketChannel.pipeline();
          channelPipeline.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4));
          channelPipeline.addLast(new LengthFieldPrepender(4));
          channelPipeline.addLast(new StringDecoder(CharsetUtil.UTF_8));
          channelPipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));
          channelPipeline.addLast(new MyClientHandler());
      }
  }
  ```

  服务端：

  ```java
  public class TestServer {
      public static void main(String [] args){
          EventLoopGroup bossGroup = new NioEventLoopGroup();//指定线程数，不设置默认为cpu的核心数乘以2，通过一系列的构造方法
          //
          EventLoopGroup workerGroup = new NioEventLoopGroup();
  
          ServerBootstrap serverBootstrap = new ServerBootstrap();
          serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).
                  childHandler(new TestServerInitializer());
          try {
              ChannelFuture channelFuture = serverBootstrap.bind(8898).sync();
              channelFuture.channel().closeFuture().sync();
          } catch (Exception e) {
              e.printStackTrace();
          } finally {
             bossGroup.shutdownGracefully();
             workerGroup.shutdownGracefully();
          }
      }
  }
  
  public class TestServerHandler extends SimpleChannelInboundHandler<String> {
      @Override
      protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception {
           System.out.println(channelHandlerContext.channel().remoteAddress()+"server receive:"+s);
           channelHandlerContext.channel().writeAndFlush("server 发送的 UUID");//需要channel方法
          channelHandlerContext.channel().writeAndFlush(Unpooled.copiedBuffer("helloworld", Charset.forName("utf-8")));
      }
      @Override
      public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
          cause.printStackTrace();
          ctx.close();
      }
  
  }
  
  public class TestServerInitializer extends ChannelInitializer<SocketChannel> {
      @Override
      protected void initChannel(SocketChannel socketChannel) throws Exception {
          ChannelPipeline pipeline = socketChannel.pipeline();
  
          pipeline.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4));
          pipeline.addLast(new LengthFieldPrepender(4));
          //字符串解码
          pipeline.addLast(new StringDecoder(CharsetUtil.UTF_8));
          //字符串编码
          pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));
          //自己定义的处理器
          pipeline.addLast(new TestServerHandler());
      }
  }
  ```

  

- 扩展实例：实现聊天程序

  客户端

  ```java
  public class MyChatClient {
      public static void main(String [] args){
          EventLoopGroup eventLoopGroup = new NioEventLoopGroup();
          try {
              Bootstrap bootstrap = new Bootstrap();
              bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class).handler(new MyChatClientInitializer());
               Channel channel = bootstrap.connect("localhost",8898).sync().channel();
              BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
              while(true){
                 channel.writeAndFlush(bufferedReader.readLine() + "\r\n");
              }
          } catch (Exception e) {
              e.printStackTrace();
          } finally {
              eventLoopGroup.shutdownGracefully();
          }
      }
  }
  public class MyChatClientHandler extends SimpleChannelInboundHandler<String > {
      @Override
      protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception {
          System.out.println(s);
  //        channelHandlerContext.writeAndFlush("client 发送的:UUID");
      }
  
  //    @Override
  //    public void channelActive(ChannelHandlerContext ctx) throws Exception {
  //        ctx.writeAndFlush("来自客户端的问候");
  //    }
  
      @Override
      public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
          cause.printStackTrace();
          ctx.close();
      }
  }
  
  public class MyChatClientInitializer extends ChannelInitializer<SocketChannel> {
      @Override
      protected void initChannel(SocketChannel socketChannel) throws Exception {
          ChannelPipeline channelPipeline = socketChannel.pipeline();
          channelPipeline.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4));
          channelPipeline.addLast(new LengthFieldPrepender(4));
          channelPipeline.addLast(new StringDecoder(CharsetUtil.UTF_8));
          channelPipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));
          channelPipeline.addLast(new MyChatClientHandler());
      }
  }
  ```

  服务端：

  ```java
  public class ChatServer {
      public static void main(String [] args) throws  Exception{
          EventLoopGroup bossGroup = new NioEventLoopGroup();
          EventLoopGroup workerGroup = new NioEventLoopGroup();
  
          ServerBootstrap serverBootstrap = new ServerBootstrap();
          serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(new ChatServerInitializer());
          //Handler针对bossGroup，childHandler针对workerGroup
          try {
              ChannelFuture channelFuture = serverBootstrap.bind(8898).sync();
              channelFuture.channel().closeFuture().sync();
          } finally {
             bossGroup.shutdownGracefully();
             workerGroup.shutdownGracefully();
          }
      }
  }
  public class ChatServerHandler extends SimpleChannelInboundHandler<String> {
  
     private static   ChannelGroup channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);//注意需要private static
      @Override
      protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception {
               Channel channel =  channelHandlerContext.channel();
               channelGroup.forEach(ch -> {
                   if(ch != channel){
                         ch.writeAndFlush(channel.remoteAddress() + "发送的消息" + s + "\n");
                   }else{
                         ch.writeAndFlush("自己" + s + "\n");
                   }
               });
      }
     //向客户端发送服务连接消息
      @Override
      public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
        Channel channel = ctx.channel();
        channelGroup.writeAndFlush("用户--" + channel.remoteAddress() + "加入\n");
        channelGroup.add(channel);
      }
    //
      @Override
      public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
          Channel channel = ctx.channel();
          channelGroup.writeAndFlush("用户--" + channel.remoteAddress() + "离开\n");
          channelGroup.remove(channel);
      }
  
      @Override
      public void channelActive(ChannelHandlerContext ctx) throws Exception {
          Channel channel = ctx.channel();
          System.out.println(channel.remoteAddress() + "上线");
      }
  
      @Override
      public void channelInactive(ChannelHandlerContext ctx) throws Exception {
          Channel channel = ctx.channel();
          System.out.println(channel.remoteAddress() + "下线");
      }
  
      @Override
      public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
          cause.printStackTrace();
          ctx.close();
      }
  }
  public class ChatServerInitializer extends ChannelInitializer<SocketChannel> {
      @Override
      protected void initChannel(SocketChannel socketChannel) throws Exception {
          System.out.println("ChannelInitializer"+this);
          System.out.println("SocketChannel"+socketChannel);
          ChannelPipeline pipeline = socketChannel.pipeline();
          pipeline.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4));
          pipeline.addLast(new LengthFieldPrepender(4));
          //字符串解码
          pipeline.addLast(new StringDecoder(CharsetUtil.UTF_8));
          //字符串编码
          pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));
          //自己定义的处理器
          pipeline.addLast(new ChatServerHandler());
  
      }
  }
  ```

  为什么服务器端向客户端发送数据需要channel,但是客户端不需要呢？

  

- netty实现心跳机制

  客户端：

  ```java
  public class HeartBeatClient {
      public static void main(String [] args){
          EventLoopGroup eventLoopGroup = new NioEventLoopGroup();
          try {
              Bootstrap bootstrap = new Bootstrap();
              bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class).handler(new HeartBeatClientInitializer());
               Channel channel = bootstrap.connect("localhost",8898).sync().channel();
              BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
              while(true){
                 channel.writeAndFlush(bufferedReader.readLine() + "\r\n");
              }
          } catch (Exception e) {
              e.printStackTrace();
          } finally {
              eventLoopGroup.shutdownGracefully();
          }
      }
  }
  public class HeartBeatClientHandler extends SimpleChannelInboundHandler<String > {
      @Override
      protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception {
          System.out.println(s);
  //        channelHandlerContext.writeAndFlush("client 发送的:UUID");
      }
  
  //    @Override
  //    public void channelActive(ChannelHandlerContext ctx) throws Exception {
  //        ctx.writeAndFlush("来自客户端的问候");
  //    }
  
      @Override
      public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
          cause.printStackTrace();
          ctx.close();
      }
  }
  
  public class HeartBeatClientInitializer extends ChannelInitializer<SocketChannel> {
      @Override
      protected void initChannel(SocketChannel socketChannel) throws Exception {
          ChannelPipeline channelPipeline = socketChannel.pipeline();
          channelPipeline.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4));
          channelPipeline.addLast(new LengthFieldPrepender(4));
          channelPipeline.addLast(new StringDecoder(CharsetUtil.UTF_8));
          channelPipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));
          channelPipeline.addLast(new HeartBeatClientHandler());
      }
  }
  
  ```

  服务端：

  ```java
  public class HearBeatServer {
      public static void main(String [] args) throws  Exception{
          EventLoopGroup bossGroup = new NioEventLoopGroup();
          EventLoopGroup workerGroup = new NioEventLoopGroup();
  
          ServerBootstrap serverBootstrap = new ServerBootstrap();
          serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new HearBeatServerInitializer());
          //Handler针对bossGroup，childHandler针对workerGroup
          try {
              ChannelFuture channelFuture = serverBootstrap.bind(8898).sync();
              channelFuture.channel().closeFuture().sync();
          } finally {
             bossGroup.shutdownGracefully();
             workerGroup.shutdownGracefully();
          }
      }
  }
  public class HearBeatServerHandler extends ChannelInboundHandlerAdapter{
  
      @Override
      public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
         if(evt instanceof IdleStateEvent){
             IdleStateEvent event = (IdleStateEvent)evt;
             String eventType = null;
             switch (event.state()){
                 case READER_IDLE:
                     eventType = "读空闲";
                     break;
                 case WRITER_IDLE:
                     eventType = "写空闲";
                     break;
                 case ALL_IDLE:
                     eventType = "读写空闲";
                     break;
             }
             System.out.println(ctx.channel().remoteAddress() + eventType+ "超时");
             ctx.channel().close();
         }
      }
  }
  public class HearBeatServerInitializer extends ChannelInitializer<SocketChannel> {
      @Override
      protected void initChannel(SocketChannel socketChannel) throws Exception {
          ChannelPipeline pipeline = socketChannel.pipeline();
  
         pipeline.addLast(new IdleStateHandler(8,2,10, TimeUnit.SECONDS));//用户心跳检测，tcp长连接
         //netty提供的检测读写间隔的handler,服务端在指定时间内读到数据或者一定时间读取到客户端的数据但是没有写出数据，就会触发这个handler
          //自己定义的处理器
          pipeline.addLast(new HearBeatServerHandler());
  
      }
  }
  ```

  

- netty与websoket：

  netty支持websocket协议，webSocket是长连接，全双工的通信，服务器和客户端之间可以双向的随时发送请求，

  服务端可以主动向客户端推送数据，不用客户端主动去轮询

  http:基于请求-响应的方式

  http1.0:session保持连接的状态

  http1.1:keep-alive，设定连接的时间，如2秒，在两秒内发送请求会

  复用已有的连接，而不是重新建立连接。

  ```java
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>websocket</title>
  </head>
  <body>
  <script>
      var socket;
      if(window.WebSocket){
          socket = new WebSocket("ws://localhost:8898/ws");
          socket.onmessage = function (ev) {
              var  ta = document.getElementById("responseText");
              ta.value = ta.value + "\n"+ev.data;
          }
          socket.onopen = function (ev) {
              var  ta = document.getElementById("responseText");
               ta.value = "连接开启";
          }
          socket.onclose = function (ev) {
              var  ta = document.getElementById("responseText");
              ta.value = ta.value + "\n" + "连接断开";
          }
  
      }else{
          alert("浏览器不支持websocket");
      }
      function send(message) {
          if(!window.WebSocket){
              return;
          }
          if(socket.readyState == WebSocket.OPEN){
              socket.send(message)
          } else{
              alert("连接尚未开启");
          }
          
      }
  </script>
  <form onsubmit="return false">
  
      <textarea name = "message" style="width: 400px; height: 200px"></textarea>
      <input type="button" value="发送数据" onclick="send(this.form.message.value)">
  
      <h1>服务器输出</h1>
      <textarea id = "responseText" style="width: 400px; height: 200px"></textarea>
      <input type="button" value="清空数据" onclick="" >
  </form>
  
  </body>
  </html>
  ```

```java
public class WebSocketServer {
    public static void main(String [] args) throws  Exception{
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();

        ServerBootstrap serverBootstrap = new ServerBootstrap();
        serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(new WebSocketInitializer());
        try {
            ChannelFuture channelFuture = serverBootstrap.bind(8898).sync();
            channelFuture.channel().closeFuture().sync();
        } finally {
           bossGroup.shutdownGracefully();
           workerGroup.shutdownGracefully();
        }
    }
}
public class WebSocketInitializer extends ChannelInitializer<SocketChannel> {
    @Override
    protected void initChannel(SocketChannel socketChannel) throws Exception {
        ChannelPipeline pipeline = socketChannel.pipeline();

        pipeline.addLast(new HttpServerCodec());
        pipeline.addLast(new ChunkedWriteHandler());
        pipeline.addLast(new HttpObjectAggregator(8192));
        //netty会把http请求分成段的，如httpmessage、httpcontent,这个handler会把请求聚合成FullHttpRequest，响应封装成FullHttpResponse
        pipeline.addLast(new WebSocketServerProtocolHandler("/ws"));//支持websocket,websocket数据以frame的方式传递
        //自己定义的处理器
        pipeline.addLast(new WebSocketServerHandler());
    }
}
public class WebSocketServerHandler extends SimpleChannelInboundHandler<TextWebSocketFrame> {
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception {
        System.out.println("收到消息"+msg.text());
        ctx.channel().writeAndFlush(new TextWebSocketFrame("服务器时间" + LocalDate.now()));
    }

    @Override
    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
      System.out.println("handlerAdded" + ctx.channel().id().asLongText());
    }

    @Override
    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
        System.out.println("handlerRemoved" + ctx.channel().id().asLongText());

    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
      System.out.println("发生异常");
      ctx.close();
    }
}
```





- netty的基本模式 reactor:

  反应器模式,主要参考两篇文档

  scalable IO in java 

  https://www.cnblogs.com/crazymakercircle/p/9833847.html

  基础设计(单线程)：就是一个线程，能够检测客户端向服务端发送的连接，当连接（事件）建立之后，reactor会分发正确的handler进行处理，acceptor的作用就是接受连接，也就是连接事件

  ![img](C:/Users/guosheng/AppData/Local/YNote/data/echosguowin@163.com/01442c2410d94f418238e40bcee33e5c/clipboard.png)

  Reactor意图:处理一个或者多个客户端并发的向一个应用发送请求。

  ![img](C:/Users/guosheng/AppData/Local/YNote/data/echosguowin@163.com/ffcb490c09ac4c58a3c083e57819a453/clipboard.png)

  acceptor就是一个handler在channelread0当中将channel绑定到subreactor上，就是bossgroup 与workergroup之间的转移纽带,每次channel的创建，channelpipleLine 都会创建，并且都会将acceptor添加到channelpipleLine 处理栈的最后一个

  ![img](C:/Users/guosheng/AppData/Local/YNote/data/echosguowin@163.com/f1b77a6deef747d6903cdc7143f5517f/clipboard.png)

  netty中：bossGroup就是连接事件，连接成功之后netty将selectionKey对象的socketChannel对象取出封装成NiosocketChannel,然后将这个channel注册到workerGroup的选择器当中，那么以后每次这个通道有事件发生的时候直接和workerGroup进行交互

  reactor一共有五种角色

  Handle:句柄或者描述符，本质上表示一种资源是由操作系统提供：该资源用于表示一个个的事件，比如文件描述符，或者网络编程中的socket描述符。既可以来自内部，也可以来自外部，比如客户端向服务端发送数据，内部事件：操作系统产生的定时器事件。

  synchronize event demultiplexer 同步事务分离器：阻塞的

  本身是一个系统调用，用于等待事件的发生，事件可能是一个或者多个，调用方在调用的时候会被阻塞，一直阻塞到同步事件分离器上有事件产生为止。对于linux来说，指的就是常用的io多路复用比如select,poll,epoll.对应nio中的selector

   event Handler 事件处理器：

  本身由多个回调方法构成，这些回调方法构成了与应用相关的对于某个事件的反馈机制

   concrete event handler 具体事件处理器，是event handler的实现，本质上就是处理器的实现

   initiation disapatcher 初始分发器：

  实际上就是Reactor角色，本身定义了一些规范，这些规范用于控制事件的调度方式，同时又提供了应用进行事件处理器的注册、删除等设施。本身是事件处理器的核心所在，会通过同步事件分离器等待事件的发生，首先会分理出每一个事件，然后调用事件处理器，然后调用相关的回调方法来处理这些事件。

  总结nio和reactor：

  nio中的selector是一种最简扑的reactor模式：

  nio 首先open一个ServerSocketChannel，然后configureBlocking为false,然后或缺serversocket并绑定端口。

  打开selector，注册一个连接事件

  死循环：不断监听不同通道产生的时间

  遍历selectionKey事件，可以获取到对应的通道，将通道和通道感兴趣的时间注册到selector中

  业务逻辑处理不同的事件。

  reactor对nio进行封装：1.当应用想initiation disapatcher注册具体事件处理器时，应用会标识出该事件处理器希望initiation disapatcher在某个事件发生的时候向其通知该事件，该事件与handle关联

  2.initiation disapatcher会要求每个事件处理器向其内部传递handle,该handle向操作系统标识了事件处理器

  3.当所有的事件处理器注册完毕后，应用会调用handle_event来启动initiation disapatcher的事件循环

  这时，initiation disapatcher会将每个事件处理器的handle合并起来，并使用同步事件分离器等待事件的发生，比如说tcp协议层会使用同步事件分离器操作来等待客户端发送的数据到连接的socket handle上

  4.当与某个事件对应的handle变成ready状态的时候，比如说 tcp,socket 变为等待状态时，同步事件分离器就会通知initiation disapatcher

  5.initiation disapatcher会触发事件处理器的回调方法，从而响应这个处于ready状态的handle,当事件发生的时候，initiation disapatcher会被事件源激活handle作为key来寻找分发恰当的事件处理器回调方法

  6.initiation disapatcher会回调事件处理器的handle_events回调方法来执行特定于应用的功能，从而响应这个事件，所发生的的事件类型可以作为该方法参数并被该方法内部使用来执行额外的特定于服务的分离和分发

- netty源码分析：

   首先搞清楚一点netty本质上是nio的变形，同时netty重写了current中的一些工具类，基本方法和思想都类似，所以可以参照nio的流程来分析

  **1.首先设置参数：**

  这几步都是设置一些启动的参数

  ![image-20200701153137692](C:\Users\guosheng\AppData\Roaming\Typora\typora-user-images\image-20200701153137692.png)

  channel的创建是反射的方法，和nio一样都是通过ServerSocketChannel.open();打开一个channel。

  

  ![image-20200701165425309](C:\Users\guosheng\AppData\Roaming\Typora\typora-user-images\image-20200701165425309.png)

   同时在initAndRegister中会调用ServerBootstrap的init方法，绑定pipleline,并且将channelhandler都添加到pipleline中

  

   ![image-20200701165639226](C:\Users\guosheng\AppData\Roaming\Typora\typora-user-images\image-20200701165639226.png)

  **2.handlerAdd的调用流程：**

  每一次连接创建channel都会创建pipleline并且都会调用DefaultChannelPipeline的addLast，这里有一个callHandlerAdded0，就是用来调用自有的handler的handlerAdd的方法的。

  在NioEventLoop中有一个selector的引用，在NioEventLoopGroup实例化的时候初始化

  ![image-20200702093314506](C:\Users\guosheng\AppData\Roaming\Typora\typora-user-images\image-20200702093314506.png)

  

  nioeventloop就是一个线程对象,然后在dobind0里面作为一个任务被线程组执行，开始监听通道的状态即selector.select()

  ![image-20200702094016640](C:\Users\guosheng\AppData\Roaming\Typora\typora-user-images\image-20200702094016640.png)

  

  整个过程十分的清楚，和nio的执行过程非常类似，但是netty对于nio的封装非常的好，对于读取事件然后调用handler里面的不同方法（channelRead0），暂时还没有研究。

  3.注意：

  **chanelHandler、ChannelInitializer，channelPipleLine、channelHandlerContext** 这几个类

  **channelHandlercontext**是channelHandler 与channelPiple之间联系的桥梁与纽带

  每一个channelhandler都有一个channelHandlercontext，每一次pipleLine在addLast也就是将handler添加到管道的时候都会创建一个DefaultChannelHandlerContext，这个context能获取到

  handler、pipleLine、channel。

  channelpipleline实际上就是channelhandler的集合，采用了高级拦截过滤器模式，可以让用户完全控制事件的处理以及pipleline中的channelhandler之间的交互关系

  高级拦截过滤器模式：与传统拦截器模式的区别，区分了入栈和出栈的操作ChannelInboundHandler,和ChannelOutboundHandler,传统拦截器无法区分请求和响应的区别，请求和响应都会经过所有拦截器

  channelHandler中handlerAdded方法的被调用：在channelpipline添加完handler之后就会调用handlerAdded

  ![image-20200701160304295](C:\Users\guosheng\AppData\Roaming\Typora\typora-user-images\image-20200701160304295.png)

  

     ChannelInitializer，他也是一个channelHandler简化代码开发的对象，起到批量添加的作用，特殊的channel入栈处理器，将channelHandler添加到           channelPipleLine，初始化channelHandler的作用。

   在初始化的过程中，自定义的ChannelInitializer会作为handler添加到pipleline

   在addLast 中ChannelInitializer 添加到pipleLine的时候调用自定义的ChannelInitializer 的handlerAdd方法,然后调用自定义的initChannel中添加自定义的   Handler,在initchannel返回之后，这个ChannelInitializer 就会从pipleLine中移除 

  netty串行化设计理念，从消息的读取、编码以及后续 ChannelHandler的执行，始终都由 IO 线程这一个线程 EventLoop 负责

  **4.netty线程模型：**

  netty是基于事件的，大量使用了线程，线程之间会产生同步和并发问题，netty采用了如下处理方式，将线程之间的问题降到最低：

  串行化设计理念，从消息的读取、编码以及后续 ChannelHandler的执行，始终都由 IO 线程这一个线程 EventLoop 负责

  -1.eventloopgroup包含一个或者多个eventloop

  -2.一个eventloop在它的整个生命周期当中都只会与唯一一个Thread进行绑定，比如SingleThreadEventLoop

  -3.所有eventloop所处理的各种io事件都将在它所关联的那个thead上进行处理

  -4.一个channel在它的整个生命周期当中只会注册在唯一一个eventloop上，因此，channel中的诸多的方法都只会由一个线程调用，不会产生多线程的问题

  -5.一个eventloop在运行过程当中会被分配一个或者多个channel

  绝对绝对不要在channelread中做耗时的操作也不要将耗时的操作提交给eventloop去执行，因为是单线程，阻塞之后其他channel或者当前channel的事件也不会被处理，如果有耗时的操作，必须使用重启一个线程去执行

  netty中可以借助netty提供的向channelpipleLine添加ChannelHandler的时候调用的addLast()方法来传递EventExecutorGroup,这样这个Handler的channelRead和其他回调方法就会在自定义的EventExecutorGroup线程组中执行，

  ![img](C:/Users/guosheng/AppData/Local/YNote/data/echosguowin@163.com/9eb7f6ae95f34192aa724b044f2b9e62/clipboard.png)

  -6.在netty中channel的实现一定是线程安全的，基于此，我们可以存储一个channel的引用，并且在需要向远程端点发送数据时，通过这个引用来调用channel的相应方法，即使当时有很多线程都在使用它也不会出现多线程问题，而且消息一定会按顺序发送出去。

  调用channel向外写数据的时候（也就是ChannelHandlerContext中的writeAndFlush）的线程不是这个channel的eventloop，那么netty会把这个作为任务提交给这个channel的eventloop去执行。

  举例：当执行当前注册流程的不是当前线程组唯一包含的线程的时候，netty会把注册当成一个任务，这个任务由当前eventLoop进行执行，所以还是单线程。

  ![img](C:/Users/guosheng/AppData/Local/YNote/data/echosguowin@163.com/c8f243c590444ba498601b364d41096c/clipboard.png)

- netty与protobuf:

  protobuf是Google推出的基于rpc，用于进行序列化和反序列化的第三方库。

  rpc是跨语言的：主要流程

  1.定义一个接口说明文件，描述了对象（结构体），对象成员，接口方法等一系列信息

  2.通过rpc框架所提供的编译器，将接口说明文件编译成具体语言文件

  3.在客户端和服务器端分别引入编译器所生成的文件，即可像调用本地方法一样调用远程方法

  具体使用很简单。

- dubbo中的netty:

- 零拷贝深入分析：

  普通io操作：
  
  ![img](C:/Users/guosheng/AppData/Local/YNote/data/echosguowin@163.com/c83b561059664ae7abf7676684320a31/clipboard.png)
  
  linux系统上：用户空间：比如socketChannel
  
  内核空间：hardware:硬件，或者外设
  
  用户空间向内核空间发送读取数据的指令，从用户空间模式切换成内核空间模式，内核空间通过直接内存访问磁盘读取数据到内核空间的缓冲区当中，然后再把缓冲区的数据拷贝到用户空间的缓冲区。然后开始执行逻辑代码，read操作完毕。
  
  write操作：将读到的数据拷贝到内核空间，内核空间将数据写到外设（socketChannel）
  
  改进1：系统层面的零拷贝：
  
  ![img](C:/Users/guosheng/AppData/Local/YNote/data/echosguowin@163.com/423240817aca44f582156911ac83a577/clipboard.png)
  
  sendfile指令：用户空间没有拷贝操作，全部都是在内核空间进行，而且只有两次上下文的切换
  
  内存映射文件：
  
  改进2：通过scaterhe 和gather直接读取数据到内核空间缓冲区:
  
  ![img](C:/Users/guosheng/AppData/Local/YNote/data/echosguowin@163.com/6bc6217c6bac4345bca1f37405d09045/clipboard.png)
  
  真正的零拷贝全流程：dma直接内存访问
  
  将硬盘的数据拷贝到内核空间缓冲区并将数据描述符（引用地址）拷贝到socket buffer，这就是scatter操作，协议引擎就使用gather操作读取这两个数据发送出去
  
  ![img](C:/Users/guosheng/AppData/Local/YNote/data/echosguowin@163.com/6824f40b42924ebebc75a003e6c5ea3d/clipboard.png)
  
  第二种阐述：
  
  循环的从磁盘中读取数据到缓冲区，再将缓冲区的内容发送到socket,但是由于linux的i/o操作默认是缓冲i/o。当应用程序访问某块数据的时候，操作系统首先会检查，是不是最近访问过此文件，文件内容是否存在内核缓冲，如果是，操作系统会直接根据read系统调用提供的buf地址，将内核缓冲区的内容拷贝到buf所指定的用户空间缓冲区当中，如果不是，操作系统会首先将磁盘上的数据拷贝到内核缓冲区，然后再将内核缓冲区的内容拷贝到用户空间缓冲。然后write系统调用把用户缓冲区的内容拷贝到网络堆栈相关的内核缓冲区中，最后由socket把内核缓冲区的内容发送到网卡上。
  
  这个过程一共发生了四次数据拷贝，并且用户态和内核态有多次切换
  
  ![img](C:/Users/guosheng/AppData/Local/YNote/data/echosguowin@163.com/ad71524b0d794256b44fe1768fdab3c2/8e1b9a521f1ae38e9b0dab1650ced67.jpg)
  
  所以零拷贝的一个类型就是：数据传输不在经过user space
  
  方案1：调用mmap(）方法，当磁盘上的数据通过dma拷贝到内核缓冲区，操作系统会把这段内核缓冲区与应用程序共享，这样就不需要拷贝到用户缓冲区了。但是缺点是当map了一个文件，如果这个文件被另一个线程截断（truncate）的时候，write系统会因为访问非法地址而被终止，导致数据的缺失。这需要向文件租借锁
  
  方案2：linux在2.1开始使用sendfile来简化操作，过程如下
  
  sendfile调用dma引擎将文件内容拷贝到内核缓冲区，然后将带有文件位置和长度信息的缓冲区描述符添加到socket缓冲区中去，也就是scatter操作，这一步不会将内核数据拷贝socket缓冲区中，dma引擎会将内核缓冲区的数据拷贝到协议引擎中去，也就是gathering操作，避免了最后一次拷贝。这种方式需要硬件和驱动程序配合
  
  ![img](C:/Users/guosheng/AppData/Local/YNote/data/echosguowin@163.com/dbe29ca82ae74039b2e73270890995ad/f739b3a420d0208de5303a0e038c1f3.png)
  
  方案3：使用splice,能够支持在两个文件描述符之间移动数据，而且不需要数据在内核空间和用户空间来回拷贝。但是必须保证有一方式管道设备
  
  
  
  

# spring中的异步编程应用：

@Async("taskExecutor")

需要自定义线程执行组

@Configuration

public class ExcutorConfig {

​    @Bean

​    public Executor taskExecutor() {

​        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();

​        executor.setCorePoolSize(3);

​        executor.setMaxPoolSize(3);

​        executor.setQueueCapacity(500);

​        executor.setThreadNamePrefix("执行异步任务");

​        executor.initialize();

​        return executor;

​    }

}

